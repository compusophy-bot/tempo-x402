# tempo-x402

Pay-per-request APIs on the Tempo blockchain. Clients sign EIP-712 payment
authorizations, servers gate content behind HTTP 402, facilitators settle
payments on-chain via transferFrom.

Live demo: https://x402-gateway-production-5018.up.railway.app
Source: https://github.com/compusophy/tempo-x402
Crates: https://crates.io/crates/tempo-x402

## Installation

```toml
[dependencies]
tempo-x402 = "0.9"
```

The crate is published as `tempo-x402` but the library name is `x402`:

```rust
use x402::scheme::SchemeServer;
use x402::scheme_server::TempoSchemeServer;
```

## The Flow

```
┌────────┐         ┌────────┐         ┌─────────────┐         ┌───────┐
│ Client │         │ Server │         │ Facilitator │         │ Chain │
└───┬────┘         └───┬────┘         └──────┬──────┘         └───┬───┘
    │                  │                     │                    │
    │  GET /resource   │                     │                    │
    │─────────────────>│                     │                    │
    │                  │                     │                    │
    │  402 + payment   │                     │                    │
    │  requirements    │                     │                    │
    │<─────────────────│                     │                    │
    │                  │                     │                    │
    │  [sign EIP-712]  │                     │                    │
    │                  │                     │                    │
    │  GET /resource   │                     │                    │
    │  + PAYMENT-      │                     │                    │
    │    SIGNATURE hdr │                     │                    │
    │─────────────────>│                     │                    │
    │                  │                     │                    │
    │                  │  POST /verify-and-  │                    │
    │                  │  settle             │                    │
    │                  │────────────────────>│                    │
    │                  │                     │                    │
    │                  │                     │  transferFrom()    │
    │                  │                     │───────────────────>│
    │                  │                     │                    │
    │                  │                     │  tx hash           │
    │                  │                     │<───────────────────│
    │                  │                     │                    │
    │                  │  settlement result  │                    │
    │                  │<────────────────────│                    │
    │                  │                     │                    │
    │  200 + content   │                     │                    │
    │  + tx hash       │                     │                    │
    │<─────────────────│                     │                    │
```

Step by step:
1. Client requests a protected endpoint
2. Server returns 402 with PaymentRequirements (price, token, recipient)
3. Client signs EIP-712 PaymentAuthorization, retries with PAYMENT-SIGNATURE header
4. Server forwards to facilitator's /verify-and-settle endpoint
5. Facilitator verifies signature, checks balance/allowance/nonce, calls transferFrom
6. Server returns content + settlement transaction hash

## Client Example

```rust
use alloy::signers::local::PrivateKeySigner;
use x402::scheme::SchemeServer;
use x402::scheme_server::TempoSchemeServer;

#[tokio::main]
async fn main() {
    let signer: PrivateKeySigner = "0xPRIVATE_KEY".parse().unwrap();
    let client = X402Client::new(TempoSchemeClient::new(signer));

    match client.fetch("https://api.example.com/data", reqwest::Method::GET).await {
        Ok((response, settlement)) => {
            let body: serde_json::Value = response.json().await.unwrap();
            println!("Data: {body}");
            if let Some(s) = settlement {
                println!("Paid via tx: {}", s.transaction);
            }
        }
        Err(e) => eprintln!("Error: {e}"),
    }
}
```

## Types

### PaymentRequirements (402 response body, in `accepts` array)

```rust
pub struct PaymentRequirements {
    pub scheme: String,              // "tempo-tip20"
    pub network: String,             // "eip155:42431"
    pub price: String,               // "$0.001"
    pub asset: Address,              // token contract
    pub amount: String,              // "1000" (smallest unit)
    pub pay_to: Address,             // recipient
    pub max_timeout_seconds: u64,
    pub description: Option<String>,
    pub mime_type: Option<String>,
}
```

### PaymentPayload (PAYMENT-SIGNATURE header, base64-encoded JSON)

```rust
pub struct PaymentPayload {
    pub x402_version: u32,           // 1
    pub payload: TempoPaymentData,
}

pub struct TempoPaymentData {
    pub from: Address,               // payer
    pub to: Address,                 // recipient
    pub value: String,               // amount
    pub token: Address,              // token contract
    pub valid_after: u64,            // unix timestamp
    pub valid_before: u64,           // unix timestamp
    pub nonce: FixedBytes<32>,       // random bytes
    pub signature: String,           // 0x-prefixed EIP-712 sig
}
```

### SettleResponse (from facilitator, in PAYMENT-RESPONSE header)

```rust
pub struct SettleResponse {
    pub success: bool,
    pub error_reason: Option<String>,
    pub payer: Option<Address>,
    pub transaction: String,         // tx hash
    pub network: String,             // "eip155:42431"
}
```

## Traits

```rust
// Client: signs payments
pub trait SchemeClient: Send + Sync {
    async fn create_payment_payload(&self, x402_version: u32, requirements: &PaymentRequirements)
        -> Result<PaymentPayload, X402Error>;
}

// Facilitator: verifies and settles
pub trait SchemeFacilitator: Send + Sync {
    async fn verify(&self, payload: &PaymentPayload, requirements: &PaymentRequirements)
        -> Result<VerifyResponse, X402Error>;
    async fn settle(&self, payload: &PaymentPayload, requirements: &PaymentRequirements)
        -> Result<SettleResponse, X402Error>;
}

// Server: parses prices
pub trait SchemeServer: Send + Sync {
    fn parse_price(&self, price: &str) -> Result<(String, Address), X402Error>;
}
```

Implementations: `TempoSchemeClient`, `TempoSchemeFacilitator`, `TempoSchemeServer`

## Chain Config

```rust
use x402::constants::ChainConfig;

let config = ChainConfig::default();
// chain_id: 42431
// network: "eip155:42431"
// scheme_name: "tempo-tip20"
// default_token: 0x20c0000000000000000000000000000000000000
// token_decimals: 6
// rpc_url: "https://rpc.moderato.tempo.xyz"
```

Custom chain: `TempoSchemeClient::with_chain_config(signer, config)`

## Utilities

```rust
// EIP-712
use x402::eip712;
let hash = eip712::signing_hash(&auth);
let nonce = eip712::random_nonce();
let recovered = eip712::verify_signature(&auth, &sig_bytes)?;

// TIP-20 on-chain
use x402::tip20;
let balance = tip20::balance_of(&provider, token, owner).await?;
let allowance = tip20::allowance(&provider, token, owner, spender).await?;
let tx = tip20::transfer_from(&provider, token, from, to, value).await?;
let tx = tip20::approve(&provider, token, spender, amount).await?;

// HMAC (server <-> facilitator auth)
use x402::hmac;
let sig = hmac::compute_hmac(secret, body);
let valid = hmac::verify_hmac(secret, body, &sig);

// Nonce store (replay protection)
use x402::nonce_store::{InMemoryNonceStore, SqliteNonceStore, NonceStore};
let store = SqliteNonceStore::open("./nonces.db")?;
store.try_use(nonce);  // atomic check-and-record
store.is_used(&nonce);
store.purge_expired(300);
```

## Gateway

The gateway is a relay/proxy that adds x402 payment rails to any HTTP API.

### Gateway Endpoints

| Method | Path | Payment | Description |
|--------|------|---------|-------------|
| POST | `/register` | Platform fee | Register a new endpoint |
| GET | `/endpoints` | Free | List all endpoints |
| GET | `/endpoints/:slug` | Free | Get endpoint details |
| PATCH | `/endpoints/:slug` | Platform fee | Update endpoint (owner only) |
| DELETE | `/endpoints/:slug` | Platform fee | Deactivate endpoint (owner only) |
| GET | `/analytics` | Free | Per-endpoint payment stats and revenue |
| GET | `/analytics/:slug` | Free | Stats for a single endpoint |
| ANY | `/g/:slug/*` | Endpoint price | Proxy to target API |

### Gateway Usage

```bash
# Register an endpoint (returns 402, sign and retry)
curl -X POST https://x402-gateway.example.com/register \
  -H "Content-Type: application/json" \
  -d '{"slug": "my-api", "target_url": "https://api.example.com", "price": "$0.05"}'

# Call a proxied endpoint
curl https://x402-gateway.example.com/g/my-api/users/123 \
  -H "PAYMENT-SIGNATURE: <base64-encoded-payment>"
```

Target APIs receive verification headers:
- `X-X402-Verified: true`
- `X-X402-Payer: 0x...`
- `X-X402-Amount: 50000`
- `X-X402-TxHash: 0x...`

## Soul (Agentic Thinking Loop)

The soul is an autonomous agent that observes node state, reasons about it via
Gemini, and can take actions (file read/write/edit, shell commands, git commits).

Modes: Observe (autonomous cycles), Chat (interactive), Code (file mutation + git),
Review (read-only analysis). Each mode has a curated tool set.

### Dynamic Tool Registry

The soul can register custom tools at runtime (`SOUL_DYNAMIC_TOOLS_ENABLED=true`):

- `register_tool` — register a new shell-based tool (Code mode only)
- `list_tools` — list all registered dynamic tools
- `unregister_tool` — remove a dynamic tool

Dynamic tools execute via shell with args passed as `TOOL_ARGS` (JSON) and
`TOOL_PARAM_{NAME}` env vars. Max 20 tools. Two handler types:
`shell_command` (inline) and `shell_script` (script in `/data/tools/`).

### Soul Env Vars

| Var | Default | Purpose |
|-----|---------|---------|
| `GEMINI_API_KEY` | — | Gemini API key (dormant without it) |
| `SOUL_DB_PATH` | `./soul.db` | Soul database path |
| `SOUL_THINK_INTERVAL_SECS` | `900` | Think loop interval |
| `SOUL_TOOLS_ENABLED` | `true` | Enable/disable tool execution |
| `SOUL_CODING_ENABLED` | `false` | Enable write/edit/commit tools |
| `SOUL_DYNAMIC_TOOLS_ENABLED` | `false` | Enable dynamic tool registry |
| `SOUL_AUTONOMOUS_CODING` | `false` | Allow autonomous code changes |
| `INSTANCE_ID` | — | VM instance ID for branch naming |

## Node (Self-Deploying)

The node composes a gateway with identity bootstrap, clone orchestration, and
the soul thinking loop. Can spawn copies of itself on Railway.

### Periodic Health Probe

The node runs a periodic health probe (default every 5 minutes) that checks all
children via `/health`. Unreachable children are marked as failed. Stuck
"deploying" children are recovered. Outdated children are auto-redeployed.

Configurable via `HEALTH_PROBE_INTERVAL_SECS` (default: 300).

## Mind (Dual-Soul Architecture)

When `MIND_ENABLED=true`, the node runs two souls in parallel:
- **Left hemisphere** — fast/analytical, Code-oriented, 900s cycles
- **Right hemisphere** — deep/holistic, Observe-oriented, 1800s cycles
- **Callosum** — active integration bus: shares summaries, gates conflicts, escalates uncertainty

Falls back to single soul when `MIND_ENABLED=false` (default).

## Prerequisites

Before paying:
1. Have pathUSD tokens: `cast rpc tempo_fundAddress 0xADDR --rpc-url https://rpc.moderato.tempo.xyz`
2. Approve facilitator: `cargo run --bin x402-approve` or `tip20::approve(&provider, token, facilitator, amount)`

## Errors

```rust
pub enum X402Error {
    SignatureError(String),
    ChainError(String),
    InvalidPayment(String),
    UnsupportedScheme(String),
    ConfigError(String),
    HttpError(String),
    SerdeError(serde_json::Error),
}
```

## Deployed Services

| Service | URL |
|---------|-----|
| Server | https://x402-server-production.up.railway.app |
| Facilitator | https://x402-facilitator-production-ec87.up.railway.app |
| Gateway | https://x402-gateway-production-5018.up.railway.app |

Health check: GET /health on any service

## Crates

| Crate | Purpose |
|-------|---------|
| `tempo-x402` | Core library: types, signing, HTTP client |
| `tempo-x402-server` | Resource server with payment middleware (multi-endpoint pricing via `PaymentConfigBuilder`) |
| `tempo-x402-facilitator` | Payment verification and settlement |
| `tempo-x402-gateway` | API gateway with endpoint registration, per-endpoint analytics, and Prometheus metrics |
| `tempo-x402-wallet` | WASM-compatible wallet — key generation, EIP-712 signing |
| `tempo-x402-node` | Self-deploying node — gateway + identity + clone orchestration + periodic health probe |
| `tempo-x402-identity` | Wallet generation, persistence, faucet funding |
| `tempo-x402-agent` | Railway API client + clone orchestration |
| `tempo-x402-soul` | Agentic thinking loop — observe/think/act cycle powered by Gemini, with coding agent and dynamic tool registry |
| `tempo-x402-mind` | Lateralized dual-soul architecture — left (analytical/code) + right (holistic/observe) + callosum integration |

## API Specs

OpenAPI 3.1 specifications are available in the `openapi/` directory:
- `facilitator.yaml` - Payment verification and settlement
- `server.yaml` - Resource server with payment middleware
- `gateway.yaml` - API relay/proxy with endpoint registration

## Version

0.11.0
